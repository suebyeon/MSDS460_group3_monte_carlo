# -*- coding: utf-8 -*-
"""group_3_monte_carlo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LwpBUKjpKT07gb5MkHBGjGD_kcyQU-4Z
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import requests
import datetime
from google.colab import data_table
from IPython.core.display import display, HTML
import yfinance as yf

from google.colab import drive
drive.mount('/content/drive')

# link to the monte carlo data folder https://drive.google.com/drive/folders/10GU2YP8ijheI8hR6IYnzU2F7A8b1Mgiu?usp=drive_link -- not sure what everyone's path is for drive

#julia filepath
#file_path = '/content/drive/My Drive/MSDS 460/Tennessee Redistricting/data/'

# paul filepath
file_path = '/content/drive/My Drive/shared_folders/MSDS 460/Monte Carlo/monte_carlo_data/each_ticker_as_a_separate_csv/'

#graham filepath
#file_path = "/content/drive/My Drive/"

# sue filepath
#file_path = '/content/drive/My Drive/MSDS 460/MSDS 460/Monte Carlo/monte_carlo_data/each_ticker_as_a_separate_csv/each_ticker_as_a_separate_csv/'

#################################################################################################################################################################################################################################
#################################################################################################################################################################################################################################
#################################################################################################################################################################################################################################
#################################################################################################################################################################################################################################
#################################################################################################################################################################################################################################

#------------------------------------         Part 1: Calculate the buy and hold returns for the 10 stocks compared to the market returns (S&P 500) over 25 years        ------------------------------------

#################################################################################################################################################################################################################################
#################################################################################################################################################################################################################################
#################################################################################################################################################################################################################################
#################################################################################################################################################################################################################################
#################################################################################################################################################################################################################################



# this code takes in the seperate price history for all ten tickers since the example from https://github.com/bryancwh/algo-trading-mean-reversion/blob/main/Mean%20Reversion.ipynb uses one df at a time
# I assume we have $100,000 to start and invest 10,000 in each ticker

# import data. each ticker's df seperately

tickers = ["XOM", "CVX", "COP", "EOG", "EPD", "WMB", "OKE", "LNG", "OXY", "HES"]

stock_dfs = {}
for ticker in tickers:
    csv_path = f"{file_path}{ticker}_data.csv"
    print(csv_path)
    stock_dfs[ticker] = pd.read_csv(csv_path)

print(stock_dfs['XOM'].head())

print(stock_dfs['CVX'].tail())



# calculating buy and hold return - buy on the first date (open price) and sell on the last row close price

stock_dfs["XOM"]['open'].iloc[0]

stock_dfs["XOM"]['close'].iloc[-1]

# https://www.investopedia.com/articles/basics/10/guide-to-calculating-roi.asp#:~:text=Return%20on%20investment%20(ROI)%20is%20an%20approximate%20measure%20of%20an,a%20wide%20range%20of%20uses.

# return = (sell price - buy price) / buy price
# e.g. buy at $100, sell at $1000

# (1000 - 100) / 100 = 9

XOM_return = (95.82491302490234 - 16.11740910042584) / 16.11740910042584

print(XOM_return)

# 10,000 invested in XOM on 1/1/1999 would be worth 10,000 * 4.94542909644023 = $ 49,454

buy_and_hold_return_dict = {}

for ticker in tickers:
    df = stock_dfs[ticker]

    first_open = df['open'].iloc[0]
    last_close = df['close'].iloc[-1]

    buy_and_hold_return = ((last_close - first_open )/ first_open)
    buy_and_hold_return_dict[ticker] = buy_and_hold_return

print(buy_and_hold_return_dict)

total_buy_and_hold_returns_energy_stocks = 0

for ticker, buy_hold_return in buy_and_hold_return_dict.items():
  final_value = 10000 * buy_hold_return
  total_buy_and_hold_returns_energy_stocks += final_value

print(f'{total_buy_and_hold_returns_energy_stocks:.2f}')

# return on initial 100k spread across all ten stocks

overall_energy_return = total_buy_and_hold_returns_energy_stocks / 100000
print(f'{overall_energy_return:.2f}')



spy_df = yf.download("SPY", start="1999-01-01", end = "2024-01-01", multi_level_index = False)

spy_df.head()

spy_df.tail()

spy_df['Open'][0]

spy_df['Close'][-1]

# calculating market retuns using SPY index for the S&P 500

spy_open = spy_df['Open'].iloc[0]
spy_close = spy_df['Close'].iloc[-1]

sp500_return = (spy_close - spy_open) / spy_open
print(sp500_return)

# buying and holding the basket of 10 energy stocks returned ~2500% while S&P 500 returned ~500%





#################################################################################################################################################################################################################################
#################################################################################################################################################################################################################################
#################################################################################################################################################################################################################################
#################################################################################################################################################################################################################################
#################################################################################################################################################################################################################################

#------------------------------------         Part 2: Applies a moving average strategy using the moving average, bollinger and rsi calculations  ------------------------------------

#------------------------------------         uses a 200 day moving average, calculates the bollinger band (a band +/- 2 standarad deviations above the 20 day moving average)  ------------------------------------

#------------------------------------         and the relative strength index over a 6 day period.    ------------------------------------

#------------------------------------         Sells when rsi is > 70 and price is > than the upper threshold, buys when rsi < 30 and price is < lower threshold  ------------------------------------

# starting with the first buy when the stock price and rsi move below the thresholds, we invest all of the amount (initially $10,000 per stock) into the stock, then sell all when it moves above the MA threshold and repeat


# rsi explanation https://www.investopedia.com/terms/r/rsi.asp

# bollinger explanation https://www.investopedia.com/terms/b/bollingerbands.asp


#------------------------------------   example from https://github.com/bryancwh/algo-trading-mean-reversion/blob/main/Mean%20Reversion.ipynb to each ticker's data        ------------------------------------

#################################################################################################################################################################################################################################
#################################################################################################################################################################################################################################
#################################################################################################################################################################################################################################
#################################################################################################################################################################################################################################
#################################################################################################################################################################################################################################

# applying the transformation from https://github.com/bryancwh/algo-trading-mean-reversion/blob/main/Mean%20Reversion.ipynb to each ticker's data

# changed the function to take in periods and thresholds as arguments so we can experiment with differnt strategies

# https://medium.com/@redsword_23261/bollinger-bands-and-rsi-crossover-trading-strategy-85246fc52379

# 20 day ma is standard for bollinger bands, 2 std dev is also standard

# rsi period of 6-14 is standard, 30 and 70 are common threshholds

def gain(value):
      if value < 0:
          return 0
      else:
          return value

def loss(value):
      if value > 0:
          return 0
      else:
          return abs(value)

def apply_mean_reversion_strategy(stock_df_dict, ma_period = 200, bollinger_period = 20, rsi_period = 6, bollinger_std = 2, rsi_low_threshold = 30, rsi_high_threshold = 70):

  updated_stock_df_dict = {}


  for ticker, df in stock_df_dict.items():

      df = df.copy()


      df['date'] = pd.to_datetime(df['date'])

      # moving average
      df['ma_200'] = df['close'].rolling(ma_period).mean()

      #Bollinger
      bollinger_period = bollinger_period
      ma_period_column = f'ma_{bollinger_period}'
      df[ma_period_column] = df['close'].rolling(bollinger_period).mean()
      df['std'] = df['close'].rolling(bollinger_period).std()
      df['upper_bollinger'] = df[ma_period_column] + (bollinger_std * df['std'])
      df['lower_bollinger'] = df[ma_period_column] - (bollinger_std * df['std'])

      # rsi
      rsi_period = rsi_period
      df['delta'] = df['close'].diff()
      df['gain'] = df['delta'].apply(lambda x: gain(x))
      df['loss'] = df['delta'].apply(lambda x: loss(x))
      df['ema_gain'] = df['gain'].ewm(span=rsi_period, adjust=False).mean()
      df['ema_loss'] = df['loss'].ewm(span=rsi_period, adjust=False).mean()
      df['rs'] = df['ema_gain'] / df['ema_loss']
      df['rsi'] = df['rs'].apply(lambda x: 100 - (100/(x+1)))

      # buy
      df['signal'] = np.where(
          (df['rsi'] < rsi_low_threshold) & (df['close'] < df['lower_bollinger']),
          1, np.nan
      )

      # sell
      df['signal'] = np.where(
          (df['rsi'] > rsi_high_threshold) & (df['close'] > df['upper_bollinger']),
          -1, df['signal']
      )

      #buy/sell next trading day
      df['signal'] = df['signal'].shift()
      df['signal'] = df['signal'].fillna(0)

      updated_stock_df_dict[ticker] = df

  return updated_stock_df_dict

# making dfs with various valus for testing

stock_dfs_original = apply_mean_reversion_strategy(stock_dfs, ma_period = 200, bollinger_period = 20, rsi_period = 6, bollinger_std = 2, rsi_low_threshold = 30, rsi_high_threshold = 70)

stock_dfs_bollinger_period_20_rsi_period_14_rsilower_30_rsi_upper_70 = apply_mean_reversion_strategy(stock_dfs, ma_period = 200, bollinger_period = 20, rsi_period = 14, bollinger_std = 2, rsi_low_threshold = 30, rsi_high_threshold = 70)

stock_dfs_bollinger_period_20_rsi_period_14_rsilower_20_rsi_upper_80 = apply_mean_reversion_strategy(stock_dfs, ma_period = 200, bollinger_period = 20, rsi_period = 14, bollinger_std = 2, rsi_low_threshold = 20, rsi_high_threshold = 80)

stock_dfs_bollinger_period_30_rsi_period_6_rsilower_30_rsi_upper_70 = apply_mean_reversion_strategy(stock_dfs, ma_period = 200, bollinger_period = 30, rsi_period = 6, bollinger_std = 2, rsi_low_threshold = 30, rsi_high_threshold = 70)

stock_dfs_bollinger_period_50_rsi_period_6_rsilower_30_rsi_upper_70 = apply_mean_reversion_strategy(stock_dfs, ma_period = 200, bollinger_period = 50, rsi_period = 6, bollinger_std = 2, rsi_low_threshold = 30, rsi_high_threshold = 70)

stock_dfs_bollinger_period_20_not_using_rsi = apply_mean_reversion_strategy(stock_dfs, ma_period = 200, bollinger_period = 20, rsi_period = 6, bollinger_std = 2, rsi_low_threshold = 10000, rsi_high_threshold = -10000)

stock_dfs_bollinger_period_50_not_using_rsi = apply_mean_reversion_strategy(stock_dfs, ma_period = 200, bollinger_period = 50, rsi_period = 6, bollinger_std = 2, rsi_low_threshold = 10000, rsi_high_threshold = -10000)

display(stock_dfs_bollinger_period_20_not_using_rsi["XOM"][500:502])

display(stock_dfs_bollinger_period_50_not_using_rsi["XOM"][500:502])

#  plot showing XOM 200 day moving avg

plt.figure(figsize=(12,5))
plt.xticks(rotation=45)

plt.plot(stock_dfs_bollinger_period_50_not_using_rsi["XOM"]['date'], stock_dfs_bollinger_period_50_not_using_rsi["XOM"]['close'], label = 'XOM close')
plt.plot(stock_dfs_bollinger_period_50_not_using_rsi["XOM"]['date'], stock_dfs_bollinger_period_50_not_using_rsi["XOM"]['ma_200'], label = '200 ma')

plt.title('XOM 200 day moving average chart')
plt.legend()
plt.show()

#  plot showing XOM 50 day moving avg


plt.figure(figsize=(12,5))
plt.xticks(rotation=45)

plt.plot(stock_dfs_bollinger_period_50_not_using_rsi["XOM"]['date'], stock_dfs_bollinger_period_50_not_using_rsi["XOM"]['close'], label = 'XOM close')
plt.plot(stock_dfs_bollinger_period_50_not_using_rsi["XOM"]['date'], stock_dfs_bollinger_period_50_not_using_rsi["XOM"]['ma_50'], label = '50 ma')

plt.title('XOM 50 day moving average chart')
plt.legend()
plt.show()

#  plot showing XOM 50 day moving avg


plt.figure(figsize=(12,5))
plt.xticks(rotation=45)

plt.plot(stock_dfs_bollinger_period_20_not_using_rsi["XOM"]['date'], stock_dfs_bollinger_period_20_not_using_rsi["XOM"]['close'], label = 'XOM close')
plt.plot(stock_dfs_bollinger_period_20_not_using_rsi["XOM"]['date'], stock_dfs_bollinger_period_20_not_using_rsi["XOM"]['ma_20'], label = '20 ma')

plt.title('XOM 20 day moving average chart')
plt.legend()
plt.show()



# XOM bollinger plot using 2x std dev of 20 day ma

plt.figure(figsize=(12,5))
plt.xticks(rotation=45)

x_axis = stock_dfs_bollinger_period_20_not_using_rsi['XOM']['date']

plt.plot(x_axis, stock_dfs_bollinger_period_20_not_using_rsi['XOM']['close'], label = 'Close')
plt.plot(stock_dfs_bollinger_period_20_not_using_rsi['XOM']['date'], stock_dfs_bollinger_period_20_not_using_rsi['XOM']['ma_20'], label = '20 ma')
plt.fill_between(x_axis, stock_dfs_bollinger_period_20_not_using_rsi['XOM']['upper_bollinger'], stock_dfs_bollinger_period_20_not_using_rsi['XOM']['lower_bollinger'], label = 'Bollinger Bands', color='lightgrey')

plt.title('XOM Price Chart with 2x 20 day MA std dev boolinger bands', fontweight="bold")
plt.legend()
plt.show()

# # XOM bollinger plot using 2x std dev of 20 day ma. using just 2010 to 2014 to show more detail


XOM_df = stock_dfs_bollinger_period_20_not_using_rsi['XOM']
XOM_truncated = XOM_df[(XOM_df['date'] > '2010-01-01') & (XOM_df['date'] < '2014-01-01')]

plt.figure(figsize=(12,5))
plt.xticks(rotation=45)

x_axis = XOM_truncated['date']

plt.plot(x_axis, XOM_truncated['close'], label = 'Close')
plt.plot(XOM_truncated['date'], XOM_truncated['ma_20'], label = '20 ma')
plt.fill_between(x_axis, XOM_truncated['upper_bollinger'], XOM_truncated['lower_bollinger'], label = 'Bollinger Bands', color='lightgrey')

plt.title('XOM Price Chart with 2x 20 day MA std dev boolinger bands', fontweight="bold")
plt.legend()
plt.show()

# define backtesting function from https://github.com/bryancwh/algo-trading-mean-reversion/blob/main/back_testing.py

def backtest_dataframe(df):
    position = 0
    net_profit = 0
    percentage_change = []
    df['buy_date'] = ''
    df['sell_date'] = ''

    for i in df.index:
        close = df["close"][i]
        date = df['date'][i]

        # Buy action
        if df["signal"][i] == 1:
            if(position == 0):
                buy_price = close
                position = 1
                df.at[i, 'buy_date'] = date
                print(f"Buying at {str(buy_price)} on {str(date)}")

        # Sell action
        elif (df["signal"][i] == -1):
            if(position == 1):
                sell_price = close
                bought = 0
                position = 0
                df.at[i, 'sell_date'] = date
                print(f"Selling at {str(sell_price)} on {str(date)}")

                # Get percentage change of trade
                pc = (sell_price/buy_price-1)*100
                percentage_change.append(pc)
                net_profit += (sell_price - buy_price)

    # Calculate trade statistics
    gains = 0
    ng = 0
    losses = 0
    nl = 0
    totalR = 1

    for i in percentage_change:
        if(i > 0):
            gains += i
            ng += 1
        else:
            losses += i
            nl += 1
        totalR = totalR * ((i/100)+1)

    totalR = round((totalR-1)*100, 2)

    if(ng > 0):
        avgGain = round(gains/ng, 2)
        maxR = round(max(percentage_change), 2)
    else:
        avgGain = 0
        maxR = "undefined"

    if(nl > 0):
        avgLoss = round(losses/nl, 2)
        maxL = round(min(percentage_change), 2)
    else:
        avgLoss = 0
        maxL = "undefined"

    if(ng > 0 or nl > 0):
        win_rate = round((ng/(ng+nl))*100, 2)
    else:
        win_rate = 0

    print()
    print('Evaluation Metrics:')
    print('-----------------------------------')
    print(f"Number of Trades: {ng+nl}")
    print(f"Number of Gains: {ng}")
    print(f"Number of Losses: {nl}")
    print(f"Total Returns: {totalR}%")
    print(f"Win Rate: {win_rate}%")
    print(f"Average Gain: {avgGain}%")
    print(f"Average Loss: {avgLoss}%")
    print(f"Max Return: {maxR}%")
    print(f"Max Loss: {maxL}%")
    print()

backtest_dataframe(stock_dfs_original["XOM"])

# same function as above but removed the print staements and made it just return the total return for the strategy

# from https://github.com/bryancwh/algo-trading-mean-reversion/blob/main/back_testing.py


def backtest_dataframe_return_just_total_return(df):
    position = 0
    net_profit = 0
    percentage_change = []
    df['buy_date'] = ''
    df['sell_date'] = ''

    for i in df.index:
        close = df["close"][i]
        date = df['date'][i]

        # Buy action
        if df["signal"][i] == 1:
            if(position == 0):
                buy_price = close
                position = 1
                df.at[i, 'buy_date'] = date
                #print(f"Buying at {str(buy_price)} on {str(date)}")

        # Sell action
        elif (df["signal"][i] == -1):
            if(position == 1):
                sell_price = close
                bought = 0
                position = 0
                df.at[i, 'sell_date'] = date
                #print(f"Selling at {str(sell_price)} on {str(date)}")

                # Get percentage change of trade
                pc = (sell_price/buy_price-1)*100
                percentage_change.append(pc)
                net_profit += (sell_price - buy_price)

    # Calculate trade statistics
    gains = 0
    ng = 0
    losses = 0
    nl = 0
    totalR = 1

    for i in percentage_change:
        if(i > 0):
            gains += i
            ng += 1
        else:
            losses += i
            nl += 1
        totalR = totalR * ((i/100)+1)

    totalR = round((totalR-1), 2)

    if(ng > 0):
        avgGain = round(gains/ng, 2)
        maxR = round(max(percentage_change), 2)
    else:
        avgGain = 0
        maxR = "undefined"

    if(nl > 0):
        avgLoss = round(losses/nl, 2)
        maxL = round(min(percentage_change), 2)
    else:
        avgLoss = 0
        maxL = "undefined"

    if(ng > 0 or nl > 0):
        win_rate = round((ng/(ng+nl))*100, 2)
    else:
        win_rate = 0

    return totalR



# return on individual stocks using default ma strategy


ma_strategy_return = {}

for ticker in tickers:
    df = stock_dfs_original[ticker]

    total_return = backtest_dataframe_return_just_total_return(df)
    ma_strategy_return[ticker] = total_return


print(ma_strategy_return)

total_ma_strategy_returns_energy_stocks = 0

for ticker, ma_returns in ma_strategy_return.items():
  final_value = 10000 * ma_returns
  total_ma_strategy_returns_energy_stocks += final_value

print(f'{total_ma_strategy_returns_energy_stocks:.2f}')

# return on 100k using default ma strategy

overall_ma_energy_return = total_ma_strategy_returns_energy_stocks / 100000
print(f'{overall_ma_energy_return:.2f}')





#################################################################################################################################################################################################################################
#################################################################################################################################################################################################################################
#################################################################################################################################################################################################################################
#################################################################################################################################################################################################################################
#################################################################################################################################################################################################################################

#------------------------------------         Part 2b: trying different values for moving average and rsi periods / rsi thresholds for buy/sell  ------------------------------------

#################################################################################################################################################################################################################################
#################################################################################################################################################################################################################################
#################################################################################################################################################################################################################################
#################################################################################################################################################################################################################################
#################################################################################################################################################################################################################################

strategies = {
    "original": stock_dfs_original,
    "bollinger20_rsi14_30_70": stock_dfs_bollinger_period_20_rsi_period_14_rsilower_30_rsi_upper_70,
    "bollinger20_rsi14_20_80": stock_dfs_bollinger_period_20_rsi_period_14_rsilower_20_rsi_upper_80,
    "bollinger30_rsi6_30_70": stock_dfs_bollinger_period_30_rsi_period_6_rsilower_30_rsi_upper_70,
    "bollinger50_rsi6_30_70": stock_dfs_bollinger_period_50_rsi_period_6_rsilower_30_rsi_upper_70,
    "bollinger20_no_rsi": stock_dfs_bollinger_period_20_not_using_rsi,
    "bollinger50_no_rsi": stock_dfs_bollinger_period_50_not_using_rsi,
}

strategy_returns = {}

for strategy, stock_dict in strategies.items():
    ma_strategy_return = {}

    for ticker in tickers:
        df = stock_dict[ticker]
        total_return = backtest_dataframe_return_just_total_return(df)
        ma_strategy_return[ticker] = total_return

    total_ma_strategy_returns = 0
    for ticker, return_multiplier in ma_strategy_return.items():
        final_value = 10000 * return_multiplier
        total_ma_strategy_returns += final_value

    print(f"Strategy: {strategy}")
    print()
    print(ma_strategy_return)
    print(f"Total return on 100k: {total_ma_strategy_returns:.2f}")

    overall_return = total_ma_strategy_returns / 100000
    print(f"Overall return : {overall_return:.2f}")
    print("-----------------------------------------------------")
    print()

    strategy_returns[strategy] = overall_return

df_best_stock_in_best_strategy = stock_dfs_bollinger_period_20_rsi_period_14_rsilower_20_rsi_upper_80['XOM']
df_worst_stock_in_best_strategy = stock_dfs_bollinger_period_20_rsi_period_14_rsilower_20_rsi_upper_80['WMB']

df_best_stock_in_best_strategy.head()

df_worst_stock_in_best_strategy.head()

# best strategy was stock_dfs_bollinger_period_20_rsi_period_14_rsilower_20_rsi_upper_80 with 2.71x return

# plotting the best performing stock (XOM 6.33x returns) in the basket based on the best strategy

plt.figure(figsize=(12,5))
plt.xticks(rotation=45)

plt.plot(df_best_stock_in_best_strategy['date'], df_best_stock_in_best_strategy['close'])
plt.scatter(df_best_stock_in_best_strategy[(df_best_stock_in_best_strategy['signal'] == 1)]['buy_date'], df_best_stock_in_best_strategy[(df_best_stock_in_best_strategy['signal'] == 1)]['close'], label = 'Buy', marker='^', c='g')
plt.scatter(df_best_stock_in_best_strategy[(df_best_stock_in_best_strategy['signal'] == -1)]['sell_date'], df_best_stock_in_best_strategy[(df_best_stock_in_best_strategy['signal'] == -1)]['close'], label = 'Sell', marker='v', c='r')

plt.title('XOM Price & Trades Using the Best Strategy: Bollinger 20 day MA / RSI 14 day MA / 20-80 RSI Threshold', fontweight="bold")
plt.legend()
plt.show()

# best strategy was stock_dfs_bollinger_period_20_rsi_period_14_rsilower_20_rsi_upper_80 with 2.71x return

# plotting the worst performing stock (WMB -0.39x returns) in the basket based on the best strategy


plt.figure(figsize=(12,5))
plt.xticks(rotation=45)

plt.plot(df_worst_stock_in_best_strategy['date'], df_worst_stock_in_best_strategy['close'])
plt.scatter(df_worst_stock_in_best_strategy[(df_worst_stock_in_best_strategy['signal'] == 1)]['buy_date'], df_worst_stock_in_best_strategy[(df_worst_stock_in_best_strategy['signal'] == 1)]['close'], label = 'Buy', marker='^', c='g')
plt.scatter(df_worst_stock_in_best_strategy[(df_worst_stock_in_best_strategy['signal'] == -1)]['sell_date'], df_worst_stock_in_best_strategy[(df_worst_stock_in_best_strategy['signal'] == -1)]['close'], label = 'Sell', marker='v', c='r')

plt.title('WMB Price & Trades Using the Best Strategy: Bollinger 20 day MA / RSI 14 day MA / 20-80 RSI Threshold', fontweight="bold")
plt.legend()
plt.show()



#################################################################################################################################################################################################################################
#################################################################################################################################################################################################################################
#################################################################################################################################################################################################################################
#################################################################################################################################################################################################################################
#################################################################################################################################################################################################################################
#------------------------------------         Part 3: Monte carlo simulation         ------------------------------------
#------------------------------------                 ------------------------------------
#------------------------------------                 ------------------------------------
#################################################################################################################################################################################################################################
#################################################################################################################################################################################################################################
#################################################################################################################################################################################################################################
#################################################################################################################################################################################################################################
#################################################################################################################################################################################################################################

import numpy as np
import pandas as pd
from scipy.stats import skew, skewnorm

def generate_synthetic_data(stock_dfs, start_date='1999-01-04', end_date='2023-12-22'):
    synthetic_dfs = {}

    for ticker, df in stock_dfs.items():
        df['date'] = pd.to_datetime(df['date'])
        df = df.sort_values('date')

        # Calculate historical daily returns
        df['return'] = (df['close'].pct_change()) #/100   # *** use log returns intead? if we stick with pct change I don't think we need to divide by 100.
        historical_returns = df['return'].dropna()

        # Calculate parameters of the historical returns
        mean_return = historical_returns.mean()
        volatility = historical_returns.std()
        historical_skew = skew(historical_returns)

        # print(f"{ticker} - Mean: {mean_return:.4f}, Volatility: {volatility:.4f}, Skewness: {historical_skew:.4f}")

        # Generate date range for the synthetic data
        synthetic_dates = pd.bdate_range(start=start_date, end=end_date, freq='B')
        num_days = len(synthetic_dates)

        # Generate synthetic returns with skewness
        volatility = max(abs(volatility), 0.001)

        synthetic_returns = skewnorm.rvs(a=historical_skew,
                                         loc=mean_return,
                                         scale=volatility,
                                         size=num_days)

        # Generate synthetic price series
        initial_price = df['close'].iloc[0]  # Start from the first known price
        synthetic_prices = [initial_price]

        for ret in synthetic_returns:
            synthetic_prices.append(synthetic_prices[-1] * (1 + ret))

        # Create a synthetic dataframe
        synthetic_df = pd.DataFrame({
            'date': synthetic_dates,
            'close': synthetic_prices[:-1]  # Match dates length
        })

        synthetic_dfs[ticker] = synthetic_df

    return synthetic_dfs

##############################################

def apply_mean_reversion_strategy(data):
  def gain(value):
      if value < 0:
          return 0
      else:
          return value

  def loss(value):
      if value > 0:
          return 0
      else:
          return abs(value)


  for ticker, df in data.items():
      df['date'] = pd.to_datetime(df['date'])

      # moving average
      df['ma_200'] = df['close'].rolling(200).mean()

      #Bollinger
      bollinger_period = 20
      df['ma_20'] = df['close'].rolling(bollinger_period).mean()
      df['std'] = df['close'].rolling(bollinger_period).std()
      df['upper_bollinger'] = df['ma_20'] + (2 * df['std'])
      df['lower_bollinger'] = df['ma_20'] - (2 * df['std'])

      # rsi
      rsi_period = 14    # *** changed from 6 to 14 to match best historical strategy
      df['delta'] = df['close'].diff()
      df['gain'] = df['delta'].apply(lambda x: gain(x))
      df['loss'] = df['delta'].apply(lambda x: loss(x))
      df['ema_gain'] = df['gain'].ewm(span=rsi_period, adjust=False).mean()
      df['ema_loss'] = df['loss'].ewm(span=rsi_period, adjust=False).mean()
      df['rs'] = df['ema_gain'] / df['ema_loss']
      df['rsi'] = df['rs'].apply(lambda x: 100 - (100/(x+1)))

      # buy
      df['signal'] = np.where(
          (df['rsi'] < 20) & (df['close'] < df['lower_bollinger']),          # *** changed from < 30 to < 20 to match best historical strategy
          1, np.nan
      )

      # sell
      df['signal'] = np.where(
          (df['rsi'] > 80) & (df['close'] > df['upper_bollinger']),        # *** changed from > 70 to > 80 to match best historical strategy
          -1, df['signal']
      )

      #buy/sell next trading day
      df['signal'] = df['signal'].shift()
      df['signal'] = df['signal'].fillna(0)

      stock_dfs[ticker] = df

  return stock_dfs

# #########################################################

def backtest_dataframe_return_just_total_return(df):
    position = 0
    net_profit = 0
    percentage_change = []
    df['buy_date'] = ''
    df['sell_date'] = ''

    for i in df.index:
        close = df["close"][i]
        date = df['date'][i]

        # Buy action
        if df["signal"][i] == 1:
            if(position == 0):
                buy_price = close
                position = 1
                df.at[i, 'buy_date'] = date
                #print(f"Buying at {str(buy_price)} on {str(date)}")

        # Sell action
        elif (df["signal"][i] == -1):
            if(position == 1):
                sell_price = close
                bought = 0
                position = 0
                df.at[i, 'sell_date'] = date
                #print(f"Selling at {str(sell_price)} on {str(date)}")

                # Get percentage change of trade
                pc = (sell_price/buy_price-1)*100
                percentage_change.append(pc)
                net_profit += (sell_price - buy_price)

    # Calculate trade statistics
    gains = 0
    ng = 0
    losses = 0
    nl = 0
    totalR = 1

    for i in percentage_change:
        if(i > 0):
            gains += i
            ng += 1
        else:
            losses += i
            nl += 1
        totalR = totalR * ((i/100)+1)

    totalR = round((totalR-1), 2)

    if(ng > 0):
        avgGain = round(gains/ng, 2)
        maxR = round(max(percentage_change), 2)
    else:
        avgGain = 0
        maxR = "undefined"

    if(nl > 0):
        avgLoss = round(losses/nl, 2)
        maxL = round(min(percentage_change), 2)
    else:
        avgLoss = 0
        maxL = "undefined"

    if(ng > 0 or nl > 0):
        win_rate = round((ng/(ng+nl))*100, 2)
    else:
        win_rate = 0

    return totalR
##############################################################

def monte_carlo_simulation(stock_dfs, num_simulations=20):

    simulation_results = []

    for sim in range(num_simulations):
        print(f"\nRunning simulation {sim + 1}/{num_simulations}...")

        # Generate random data
        synthetic_data = generate_synthetic_data(stock_dfs)

        # Apply the mean reversion strategy to generate trading signals
        simulated_data  = apply_mean_reversion_strategy(synthetic_data)

        # Backtest the strategy
        for ticker, df in simulated_data.items():
          total_return = backtest_dataframe_return_just_total_return(df)

        # Collect results
          simulation_results.append({
              'simulation': sim + 1,
              'ticker': ticker,
              'total_return': total_return
          })

    # Convert results to a DataFrame for analysis
    results_df = pd.DataFrame(simulation_results)

    return results_df

# Run the Monte Carlo simulation with 1000 simulations
# simulation_results = monte_carlo_simulation(stock_dfs)
print(monte_carlo_simulation(stock_dfs))